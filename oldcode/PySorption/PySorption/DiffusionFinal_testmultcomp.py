import os
import time
import numpy as np
import casadi as cs
import pandas as pd
from tenacity import RetryCallState
from PyCSAFT.get_pcpar import get_par
from PyCSAFT.PyCSAFTNil import Mixture
from PySorption.interparc import interparc
from matplotlib import pyplot as plt
from tkinter.filedialog import askopenfilename
from scipy.interpolate import InterpolatedUnivariateSpline
from PySorption.DiffusionsmodellPlots import Plotlist,Plotcontour,WriteHistorycsv
from PySorption.ReadXandYdatafromExcel import FasterXlrdRead
from PySorption.ReadXandYdatafromExcel import sheet
from scipy.ndimage import median_filter

class Film:
    """ The class Film inherits methods to read the DVS-excel files and to calculate Diffusion"""
    ideal=1
    n=100 #Number of points for the conc. scan of PCSAFT
    nt=300 #temporal discretization depth
    nz=20
    nz=200 #space discretization depth #200 #before 20 definitly seems to improve idas convergence#300 for case2 and plast
    indJ=0
    T=298.15 # P-T Flash is the most suitable for this project
    p=1.013*1E5
    R=8.31448
    Mode="NEAT"
    
    #Mode="Kris"
    endpoint=True #If True uses the experimental endpoint. Else it is predicted
    File=True ##If True a path to an excel file is provides. Else dummy exp data is generated
    des=False # If True the desorption experiment gets inverted into a absorbtion experiment
    NET=False #If True NET-GP is used else not
    SAFT=False #If True chemical potential is predicted by SAFT else from the experiment
    Origin=False # If True Plots are parsed to an origin file
    Actual=False # If True the actual partial pressure from the exp. data is used instead of the target
    Segmental=True

    #Change
    D12=1E-13
    #self.D23=1E-14
    E0=1E13
    tau0=1E-2
    exponent=0
    Xhi=0
    nJ=1
    RHd=[25,50,75]
    td=[100,100,100]
    wd=[0.1,0.2,0.3]
    L0d=10E-6
    
    #Kris
    kt=0
    DAPI=0
    sigma=0
    g=1
    solubility=0.03

    #Change

    def __init__(self,DATA_FILE,comp,wPolyASD=1):
        """Initialization involves Datafile molecules as dictionaries """
        self.comp=comp #list of dictionaries containing the component data
        self.molecule = comp[0]["name"]
        self.solvent = comp[1]["name"]
        self.molecule2= comp[2]["name"]
        #self.solvent2= comp[3]["name"]
        self.M1=comp[0]["Mi"]
        self.M2=comp[1]["Mi"]
        self.M3=comp[2]["Mi"]
        #self.M4=comp[3]["MI"]
        self.rho01=comp[0]["rho0"]
        self.rho02=comp[1]["rho0"] if comp[1]["rho0"]!=None else 997
        self.rho03=comp[2]["rho0"]
        #self.rho04=comp[3]["rho0"]
        self.Durchmesser=0.0145#0.007369966# dünne Filme 0.0145# erstr Film für Adrian eckig 0.007369966
        #self.Durchmesser=0.008# Neue Geometrie
        self.A0=self.Durchmesser**2*np.pi/4
        self.DATA_FILE=DATA_FILE  if isinstance(DATA_FILE, str) else DATA_FILE[0]#join("Pure",self.molecule,DATA_FILE) if isinstance(DATA_FILE, str) else join("Pure",self.molecule,DATA_FILE[0])
        # Data is read from cwd+\SorptionData\Pure\moleculename\filename
        self.wPolyASD=wPolyASD
        self.msol=1E-5




    def exp_boundary(self):
        """Read Sorption Data from Excel File generated by DVS"""
        filename=self.DATA_FILE if os.path.isfile(self.DATA_FILE) else askopenfilename()
        self.read_excel_file(filename) #if self.Mode!="Diss" else read_excel_Sotax(filename)
        self.PCSAFT(self.p,self.T) if not hasattr(self,'lna_fun') else None
        #6. Berechnung der Dicke
        wanf=self.wanf #if not self.des==True else self.wanfdes
        wreal=self.wreal #if not self.des==True else self.wrealdes
        Feuchtereal=self.Feuchtereal #if not self.des==True else self.Feuchterealdes
        Feuchteanf=self.Feuchteanf
        self.rho0ASD=self.idealdensity(self.wPolyASD/self.rho01,(1-self.wPolyASD)/self.rho03) #if not self.SAFT else self.rho_fun(0)

        wanf=np.fmax(wanf,1E-6) if self.endpoint==True else np.fmax(self.ww_fun(Feuchteanf),1E-6)
        wreal=np.fmax(wreal,1E-6) if self.endpoint==True else np.fmax(self.ww_fun(Feuchtereal),1E-6)
        rhofestEnd=self.rho0ASD/(1-wreal)#rhofestEnd3
        rhofestAnf=self.rho0ASD/(1-wanf)#rhofestAnf2
        mProbeAnf=self.mnull/(1-wanf)
        self.L0=self.mnull/self.rho0ASD/self.A0 # Annahme Volumen konstant
        #self.L0=7500*1E-6
        #self.L0=7750*1E-6
        


        print(self.L0)
        print(self.rho0ASD)

        w2II=wreal
        w1II=self.wPolyASD*(1-wreal)   #Polymer und API lösen sich nicht
        w3II=1-wreal-w1II

        w2IIanf=wanf
        w1IIanf=self.wPolyASD*(1-wanf)   #Polymer und API lösen sich nicht
        w3IIanf=1-wanf-w1IIanf

        self.rho1IIGGW=rhofestEnd*w1II
        self.rho3IIGGW=rhofestEnd*w3II
        self.rho2IIGGW=rhofestEnd*w2II

        self.rho1IIAnf=rhofestAnf*w1IIanf
        self.rho3IIAnf=rhofestAnf*w3IIanf
        self.rho2IIAnf=rhofestAnf*w2IIanf


    def Diffusion1D(self):
        """Solving of the 1D Diffusion problem """


        #PDE Parameters
        D12=self.D12
        nz=self.nz  #Anzahl an räumlichen Diskretisierungspunkten
        nt=self.nt  #Anzahl an zeitlichen Diskretisierungspunkten
        DWASDFEED=D12


        #Import PC-SAFT
        self.exp_boundary() if not hasattr(self, 'mnull') else None
        self.PCSAFT(self.p,self.T) if not hasattr(self,'lna2_fun') else None

        start_time = time.time()

        # Define Casadi Variables
        rho2II=cs.MX.sym("rho2II",nz+1)
        Time=cs.MX.sym("Time")


        zvec=np.linspace(0,self.L0,nz+1)*1E6
        deltaz=self.L0/self.nz

        rho1IIInit=self.rho1IIAnf[self.indJ]
        rho2IIInit=self.rho2IIAnf[self.indJ]
        rho3IIInit=self.rho3IIAnf[self.indJ]

        rho2sol=1E4*self.rho0ASD#+self.rho2IIAnf[self.indJ]   
        rho2IIBound=self.rho2IIGGW[self.indJ] if self.Mode!="Diss" else rho2sol
        rho2II_his=np.ones((nz+1,nt+1))*rho2IIInit
        alpha_his=np.zeros((nz+1,nt+1))
        rho2II_his[nz,:]=rho2IIBound

        


        t0=self.tlist[self.indJ][0]
        tend=self.tlist[self.indJ][-1]
        #tend=3500*60
        tspan=np.linspace(t0,np.sqrt(tend),nt+1)**2
        

        #####Solving the PDE

        #Annahme VLE
        #Einseitige Diffusion:Massenbilanz Polymer dj1=0 => rho1=const API dj3=0 => rho3=const

        rho1II=rho1IIInit*np.ones(self.nz+1)
        rho3II=rho3IIInit*np.ones(self.nz+1)

        if self.Mode=="Kris":
            r=cs.MX.sym("r",nz+1)
            alpha=cs.MX.sym("alpha",nz+1)
            wPolyASDsym=self.wPolyASD/(1-alpha)
            #rhosym=self.idealdensity(wPolyASDsym/self.rho01,(1-wPolyASDsym)/self.rho03)
            rhosym=(wPolyASDsym/self.rho01+(1-wPolyASDsym)/self.rho03)**-1
            rhosym=self.rho0ASD
            rho1II=wPolyASDsym*rhosym
            rho3II=(1-wPolyASDsym)*rhosym

            #Xnl=(1-self.wPolyASD-alpha)
            #rho3II=Xnl*rhosym
            #rho1II=rhosym-rho3II-rho2II
        elif self.Mode=="Diss":
            rho2IIBound= rho2sol
        else:
            rho1II=rho1IIInit*np.ones(self.nz+1)
            rho3II=rho3IIInit*np.ones(self.nz+1)


        #Errechne den Bereich zwischen den Volumenelementen
        rho1IIbar=self.averaging(rho1II)
        rho2IIbar=self.averaging(rho2II)
        rho3IIbar=self.averaging(rho3II)
        w1IIbar,w2IIbar,w3IIbar=self.convert_fraction(rho1IIbar,rho2IIbar,rho3IIbar)
        if self.Segmental==True:
            w1II,w2II,w3II=self.convert_fraction(rho1II,rho2II,rho3II)
            DASD=DWASDFEED/(1-w2IIbar) if not callable(DWASDFEED) else DWASDFEED(wPolyASDsym)/(1-w2IIbar)
            #DASD=DWASDFEED/(1-w2IIbar+w4IIbar)*(1+dw2dw4)**-1
            lnc2II= cs.log(w2II)
        else:
            x1II,x2II,x3II=self.convert_fraction(rho1II/self.M1,rho2II/self.M2,rho3II/self.M3)
            x1IIbar,x2IIbar,x3IIbar=self.convert_fraction(rho1IIbar/self.M1,rho2IIbar/self.M2,rho3IIbar/self.M3)
            DASD=DWASDFEED/(1-x2IIbar) if not callable(DWASDFEED) else DWASDFEED(wPolyASDsym)/(1-x2IIbar)
            lnc2II=cs.log(x2II)
        

        v2=self.v2_fun if hasattr(self,"v2_fun") else 1/self.rho02 
        epsilon=rho2IIbar*v2 if isinstance(v2, (int, float, complex)) else rho2IIbar*v2(w2IIbar)
        Xhi=cs.exp(self.Xhi*rho2IIbar/(1+epsilon))# if hasattr(self,"Xhi") else 1

        if self.Mode=="Kris":
            lna2II=cs.MX.ones(self.nz+1)
            for i in range(self.nz+1):
                lna2II[i]=self.lna2_fun(cs.vertcat(w2II[i],alpha[i])) if not self.ideal else cs.log(w2II[i])
        elif self.Mode=="MEOS":
            a1,a2=tuple(self.dickeys[self.indJ].split("_"))
            activity1=np.fmax(float(a1)/100,0.0001) #if self.indJ-1>=0 else 0.0001
            activity2=np.fmax(float(a2)/100,0.0001)
            activity1=self.Feuchteactual[np.argmin(abs(activity1-self.Feuchteactual))] if self.Actual==True and activity1>0.01 else activity1
            activity2=self.Feuchteactual[np.argmin(abs(activity2-self.Feuchteactual))] if self.Actual==True else activity2

            print(str(activity1)+" to "+str(activity2))
            print(str(rho2IIInit)+" to "+str(rho2IIBound))
            p=1
            rho2=cs.MX.sym("rho2")
            m=(activity2-activity1)/(rho2IIBound**p-rho2IIInit**p)
            b=activity1-m*rho2IIInit**p
            activity=m*rho2**p+b
            activity_fun=cs.Function("activity",[rho2],[activity])
            dactivtydrho=cs.gradient(activity,rho2)
            dactivitydrho_fun=cs.Function("activity",[rho2],[dactivtydrho])
            lna2II=cs.log(activity_fun(rho2II))
        else:
            lna2II= lnc2II if self.ideal else self.lna2_fun(w2II)

        dlna2II=self.CDF1O(lna2II)    


        #Stoffluss nach MaxwellStefan für alle z€[2,nz]
        TDF=dlna2II/deltaz #Thermodynamic driving force
        MDF=cs.MX.sym("MDF",nz)

        ####Calculate Non Fickian diffusion coefficient
        omega=(1+epsilon)**(-2)
        jMS=omega*rho2IIbar*DASD*Xhi*(TDF+MDF)

        jMS_fun=cs.Function("jMS_fun",[rho2II,MDF],[jMS])
        jBound=cs.MX.zeros(1)
        j2II=cs.vertcat(jBound,jMS_fun(rho2II,0))
        #j2II_fun=cs.Function("j2II_fun",[rho2II,alpha],[j2II])

        if self.Mode=="MEOS":
            xvec,fvec,x0,MDF_fun=self.MEOS(rho2II_his,rho2II,activity,rho2,jMS_fun)
        elif self.Mode=="Kris":
            xvec,fvec,x0=self.Kris(jMS_fun,rho2II,rho2II_his,alpha,r,w2II)
        elif self.Mode=="Diss":
            xvec,fvec,x0=self.Dissolution(jMS_fun,rho2II,rho2II_his)

        else:

            jBound=cs.MX.zeros(1)
            
            j2II=cs.vertcat(jBound,jMS_fun(rho2II,0)) #normal MDF=0
            #j2II=cs.vertcat(jBound,jMS_fun(rho2II,MDF_ext*test_ext)) #MDF externally supplied
            #
            dj2II=self.CDF1O(j2II)
            drho2dt_hist=0
            drhodtNF=cs.vertcat(dj2II/deltaz,drho2dt_hist)
            xvec=cs.vertcat(rho2II)
            fvec=cs.vertcat(drhodtNF)
            x0=cs.vertcat(rho2II_his[:,0])

        opts = {"grid":tspan,"max_num_steps":10000,"regularity_check":True,"output_t0":True}
        try:
            ergebnis=self.SolveODEs(xvec,fvec,x0,opts,Time)
        except Exception as e:
            import sys
            print("Solving was unsuccesful. A zero Array serves as an replacement for the solution" )

            print(e, file=sys.stderr)
            ergebnis=np.zeros((xvec.shape[0],self.nt+1))

        rho2IIres=ergebnis[:nz+1,:]
        if self.Mode=="Kris":
            rres=ergebnis[2*nz+2::,:]
            alphares=ergebnis[nz+1:2*nz+2,:]
        else:
            alphares=np.zeros((self.nz+1,self.nt+1))
        if self.Mode=="MEOS":
            sigmaJ_his=np.zeros((nz+1,nt+1,self.nJ))
            #rho2II_his[:,0]=x0[:nz+1].full().T[0]
            rho2II_his=np.reshape(rho2IIres,(nz+1,nt+1))
            for J in range(self.nJ):
                #sigmaJ_his[:,0,J]=x0[(nz+1)*(J+1):(nz+1)*(J+2)].full().T[0]*np.atleast_1d(self.E0)[J]
                sigmaJres=ergebnis[(nz+1)*(1+J):(nz+1)*(2+J),:]*np.atleast_1d(self.E0)[J]
                sigmaJ_his[:,:,J]=np.reshape(sigmaJres,(nz+1,nt+1))
            sigma_his=np.sum(sigmaJ_his,axis=2)
            #MDF_his=np.asarray([MDF_fun(rho2II_his[:,i],sigmaJ_his[:,i,:]/np.atleast_1d(self.E0)[J]).full().T[0] for i,val in enumerate(rho2II_his[0,:])]).T
            #MDFt=np.asarray([np.sum(MDF_his[:,i]*deltaz)/self.L0  for i,val in enumerate(MDF_his[0,:])])
        else:
            sigmaJ_his=np.zeros((nz+1,nt+1,self.nJ))
            MDFt=np.zeros(nt+1)
            MDF_his=np.zeros((nt+1,nz)).T
        alpha_his=np.reshape(alphares,(nz+1,nt+1))  
        rho2II_his=np.reshape(rho2IIres,(nz+1,nt+1))*(1-alpha_his)
        wPolyASDres=self.wPolyASD/(1-alpha_his)
        rhores=(wPolyASDres/self.rho01+(1-wPolyASDres)/self.rho03)**-1
        rhores=self.rho0ASD
        X2II_his=rho2II_his/rhores # Solvent loading
        w2II_his=X2II_his/(1+X2II_his) # solvent weight fraction
        
        #plt.plot(tspan,w2II_his[-1,:])
        #plt.show()
        #rho50=(np.max(rho2II_his)+np.min(rho2II_his))*0.5
        #z50=np.asarray([zvec[np.argmin(np.abs(rho2II_his[:,i]-rho50))] for i,val in enumerate(rho2II_his[0,:])])
        #vmax=np.average(np.gradient(z50,tspan)[nt//3:nt*3//4])
        #figII,axII=Plotlist([tspan/60,vmax*np.ones_like(tspan)],[z50,vmax*np.ones_like(tspan)],[tspan/60,vmax*np.ones_like(tspan)],[z50,vmax*np.ones_like(tspan)],Origin=True,xla="t/min**0.5",yla="z50/mum")
        #figII,axII=Plotlist([tspan/60],[z50],[tspan/60],[z50],Origin=True,xla="t/min**0.5",yla="z50")

        ## =============================================================================
        #|_|
        #|_|
        print("Diffusion simulation took--- %s seconds ---" % (time.time() - start_time))
        m=np.asarray([np.sum(rho2II_his[:-1,k]*deltaz*self.A0) for k in range(nt+1)])#Mass of water in volume elements. Last volume is a ghost volume as it is the boundary value
        #si=np.asarray([np.sum(sigma_his[:-1,k]*deltaz)/self.L0 for k in range(nt+1)])
        wt=m/(self.mnull+m)
        wt=np.asarray([np.sum(w2II_his[:-1,k]) for k in range(nt+1)])/self.nz
        #wt=np.asarray([np.sum(w2II_his[:-1,k]*deltaz)/self.L0 for k in range(nt+1)])
        wtref=self.wlist[self.indJ] if self.File else w2II_his[-1,:]
        tref=self.tlist[self.indJ] if self.File else tspan
        wt2=InterpolatedUnivariateSpline(tspan,wt,k=1)(tref)  
        self.wt=wt2
        self.wtref=wtref
        self.wtsim=wt
        self.tsim=tspan

        figI,axI=Plotlist([(tref/60)**0.5],[wtref],[(tspan/60)**0.5],[wt],Origin=False,xla="t/min**0.5",yla="w2/-")
        figI,axI=Plotlist([(tref/60)],[wtref],[(tspan/60)],[wt],Origin=False,xla="t/min",yla="w2/-")
        #figII,axII=Plotlist([tref/60,tref/60],[TDFt,MDFt],[tref/60,tref/60],[TDFt,MDFt],Origin=False,xla="t/min",yla="nabla mu/-")
        TSPAN,ZVEC=np.meshgrid(tspan,zvec)
        Plotcontour((TSPAN/60)**0.5,ZVEC,w2II_his,Origin=False,filename="w2_contour",xla=r'$t^{0.5}$/$min^{0.5}$',yla=r'z$\mu$m',zla=r'$w_2$/-')
        if self.Mode=="Kris":
            Plotcontour((TSPAN/60),ZVEC,alpha_his,Origin=False,filename="alpha_contour",xla=r't/$min$',yla=r'z$\mu$m',zla=r'$\alpha$/-')
            rsurf=np.reshape(rres[-1,:],nt+1)
            alphasurf=np.reshape(alphares[-1,:],nt+1)
            Ssurf=np.asarray([self.deltamu_fun(cs.vertcat((rho2IIres/rhores/(1+rho2IIres/rhores))[-1,i],alpha_his[-1,i])).full()[0][0] for i in range(nt+1)])
            
            figI,axI=Plotlist([(tspan/60)],[rsurf],[(tspan/60)],[rsurf],Origin=False,xla="t/min",yla="rres/µm")
            figI,axI=Plotlist([(tspan/60)],[alphasurf],[(tspan/60)],[alphasurf],Origin=False,xla="t/min",yla="alpha/-")
            
            WriteHistorycsv(Ssurf*60,alphasurf/100,rsurf/100,tsim=tspan,msim=wt/100)
        elif self.Mode=="MEOS":
            Plotcontour((TSPAN/60)**0.5,ZVEC,sigma_his,Origin=False,filename="sigma_contour",xla=r'$t^{0.5}$/$min^{0.5}$',yla=r'z$\mu$m',zla=r'log10$\sigma$/Pa')
            WriteHistorycsv(tref,sigma_his[-1,:],wtref,tsim=tspan,msim=wt)
        else:
            WriteHistorycsv(tref,wt2,wtref,tsim=tspan,msim=wt)

        #gig,gax=plt.subplots()
        #gax.set_xlabel("z/$\mu$m")
        #gax.set_ylabel("$w_{w}$\n/%",rotation=0)
        #[gax.plot(zvec,100*w2II_his[:,i*10]) for i,val in enumerate(tspan[::10]/60)]
        #w2list=[(w2II_his[:,i*10]) for i,val in enumerate(tspan[::10]/60)]
        #zlist=[zvec for i,val in enumerate(tspan[::10]/60)]
        #tlist=[np.ones_like(zvec)*val for i,val in enumerate(tspan[::10]/60)]
        #figI,axI=Plotlist(tlist,w2list,zlist,w2list,Origin=True,xla="z/$\mu$m",yla="$w_{w}$\n/%",filename="W_Profile")
        #WriteHistorycsv(zmax*60,wt2,wtref,tsim=tspan,msim=wt)
        
        plt.show()

        return wt2-wtref
        #return (wt2-wtref)/wtref
    def Dissolution(self,jMS_fun,rho2II,rho2II_his):
        deltaz=self.L0/self.nz
         #Mass of water in volume elements. Last volume is a ghost volume as it is the boundary value
        #Build solution vector
        jBound=cs.MX.zeros(1)
        j2II=cs.vertcat(jBound,jMS_fun(rho2II,0))
        dj2II=self.CDF1O(j2II)
        #deltaz=self.L0/self.nz
        #dmwdt=cs.sum1(dj2II*self.A0)
        #dmASDdt=dmwdt
        #msol=self.msol #g Wasser im Behälter
        #Vsol=msol/self.rho02
        #Vpol=self.mnull/self.rho0ASD
        #Vpol=self.A0*self.L0
        #drhoinfdt=-dmASDdt/(Vpol)*1E8

        drhoinfdt=-cs.sum1(dj2II/self.L0)*1E4*self.mnull/self.msol#*self.rho02/self.rho0ASD
        
        
        drhodtNF=cs.vertcat(dj2II/deltaz,drhoinfdt) # reduktion des Stofflusses um die amorphe Fläche die mit Kristallanteil sinkt
        xvec=cs.vertcat(rho2II)
        fvec=cs.vertcat(drhodtNF)
        x0=cs.vertcat(rho2II_his[:,0])
        return xvec,fvec,x0



    def Kris(self,jMS_fun,rho2II,rho2II_his,alpha,r,w2II):
        # WasserFeed Information
        
        alphavec=self.alphavec
        rho2GGWvec=self.rho2GGWvec
        rho2GGW_fun1=InterpolatedUnivariateSpline(alphavec[alphavec>=-0.05], rho2GGWvec[alphavec>=-0.05],k=1)
        vec=np.linspace(0,1,100)
        rho2GGW_fun=cs.interpolant("rho2GGW_fun","linear",[vec],rho2GGW_fun1(vec))
        rho2II_his[-1,0]=rho2GGW_fun(0)



        
        wwSIMraw=self.wwSIMraw
        XwSIMraw=wwSIMraw/(1-wwSIMraw)
        wAPISIMraw=self.wAPISIMraw
        rhoSIMraw=((1-wAPISIMraw)/self.rho01+(wAPISIMraw)/self.rho03)**-1
        rhoSIMraw=self.rho0ASD
        rho2GGW_fun1=InterpolatedUnivariateSpline(wAPISIMraw[::-1], (rhoSIMraw*XwSIMraw)[::-1],k=1)
        vec=np.linspace(0,1,100)
        rho2GGW_fun=cs.interpolant("rho2GGW_fun1","linear",[vec],rho2GGW_fun1(vec))
        rho2II_his[-1,0]=rho2GGW_fun1(1-self.wPolyASD)
        #vec=np.linspace(0,1-self.wPolyASD,100)
        # CNT DGL
        R=self.R
        NA=6.023E23
        kB=R/NA
        temp=self.T
        rho=self.rho03
        M=self.M3
        DAPI=self.DAPI
        g=self.g
        sigma=self.sigma
        kt=self.kt
        AR=100
        pre=rho*np.pi/(4*AR**2)
        scale_r=1E-6
        C0=rho/M*NA
        X_la=(1-self.wPolyASD)-alpha
        
        Xn_la=X_la/M
        dl_la = (1-self.wPolyASD-alpha)/(1-alpha)
        
        c_la=dl_la*(1-w2II)
        c_la_0=(1-self.wPolyASD)*(1-rho2II_his[0,0]/self.rho0ASD)
        c_GGW=self.solubility if self.ideal else 0
        dmu_sla0=cs.log(c_la_0/c_GGW) if self.ideal else self.deltamu_fun(cs.vertcat(rho2II_his[0,0]/self.rho0ASD,0))
        

        dmu_sla=cs.MX.ones(self.nz+1)
        for i in range(self.nz+1):
            dmu_sla[i]=cs.log(c_la[i]/c_GGW) if self.ideal else self.deltamu_fun(cs.vertcat(w2II[i],alpha[i]))
        rstar = ((2*sigma)/(C0*kB*temp*dmu_sla))
        
        #r0=np.ones(self.nz+1)/1E12
        r0=np.ones(self.nz+1)*2*sigma/(C0*dmu_sla0*kB*temp)*scale_r #taking r_star might solve the numerical problems in the volume element before the surface. Critical radius
        alpha0=pre*(r0/scale_r)**3/self.mnull #1 Nuceli per kg of dry mass
        deltaG=sigma**3*(16*np.pi)/(3*(C0*kB*temp*dmu_sla)**2)
        beta=cs.fmin((rho2II-rho2II_his[0,0])/(rho2II_his[-1,0]-rho2II_his[0,0]),1)
        ze=(kB*temp/sigma)**(1.5)*C0/(8*cs.pi)*dmu_sla**2
        f=4*np.pi*rstar*DAPI*Xn_la*NA*cs.fmax(beta,1E-4)
        
        dNdt = ze*f*C0*cs.exp(-deltaG/(kB*temp))#*cs.exp(-NA)/NA**0.5
        drdt = cs.fmax(1/scale_r*kt*cs.fmax(beta,1E-4)*(dmu_sla)**g,0)
        dalphadr=3*alpha/r
        dalphadN=pre*(r*scale_r)**3
        dalphadt=cs.fmax((drdt*dalphadr+dNdt*dalphadN),0)


        #BOUNDARY
        alphasym=cs.MX.sym("alphasym")
        
        drho2GGWsymdalpha=cs.gradient(rho2GGW_fun(alphasym),alphasym)
        drho2GGWsymdalpha_fun=cs.Function("drho2GGWdalphafun",[alphasym],[drho2GGWsymdalpha])
        drho2GGWdalpha=drho2GGWsymdalpha_fun(alpha)

        wFLsym=cs.MX.sym("wFLsym")
        wFL=dl_la
        drho2GGWdwFL=cs.gradient(rho2GGW_fun(wFLsym),wFLsym)
        drho2GGWdwFL_fun=cs.Function("dXwdwFL_fun",[wFLsym],[drho2GGWdwFL])
        drho2GGWdwFL=drho2GGWdwFL_fun(wFL)

        drho2dt_hist=drho2GGWdalpha*dalphadt
        drho2dt_hist=(-self.wPolyASD)/(1-alpha)**2*drho2GGWdwFL*dalphadt


        #Build solution vector
        jBound=cs.MX.zeros(1)
        j2II=cs.vertcat(jBound,jMS_fun(rho2II,0))
        dj2II=self.CDF1O(j2II)
        deltaz=self.L0/self.nz
        drhodtNF=cs.vertcat(dj2II/deltaz,drho2dt_hist[-1]) # reduktion des Stofflusses um die amorphe Fläche die mit Kristallanteil sinkt
        xvec=cs.vertcat(rho2II,alpha,r)
        fvec=cs.vertcat(drhodtNF,dalphadt,drdt)
        x0=cs.vertcat(rho2II_his[:,0],alpha0,r0)
        return xvec,fvec,x0



    def MEOS(self,rho2II_his,rho2II,activity,rho2,jMS_fun):
        nJ=int(self.nJ)
        E0=self.E0 #E modulus of first Spring
        tau0=self.tau0
        eta0,self.eta0=E0*tau0,E0*tau0
        exponent=self.exponent #if hasattr(self,'exponent') else 0
        EJ=cs.MX(E0)#cs.MX.ones(nJ)*E0 #Switched? E0 is maxwell E1 is eq 23.07
        etaJ=cs.MX(eta0)
        tauJ=etaJ/EJ
        #PDE Parameters
        nz=self.nz  #Anzahl an räumlichen Diskretisierungspunkten
        nt=self.nt  #Anzahl an zeitlichen Diskretisierungspunkten
        # Define Casadi Variables
        sigmaJ=cs.MX.sym("sigmaJ",nz+1,nJ)
        sigma=cs.sum2((sigmaJ.T*EJ).T)
        dsigma=self.CDF1O(sigma)
        deltaz=self.L0/self.nz
        v2=1/self.rho02
        v2_fun=self.v2_fun
        rho_fun=self.rho_fun

        epsilon=v2*rho2II
        X2II=rho2II/self.rho0ASD
        w2II=X2II/(X2II+1)
        #epsilon=v2_fun(w2II)*rho2II
        #epsilon=(rho2II+self.rho0ASD)/rho_fun(w2II)-1

        WL=cs.exp(-rho2II/(1+epsilon)*exponent)
        #WL=cs.exp(-w2II*exponent)
#____________________________
        from Pylomer.PyGT import Tggt
        w2=w2II
        w10=self.wPolyASD+w2II*0
        w30=1-w10
        wnull=w2II*0
        w1=(1-w2)*w10
        w3=(1-w2)*w30


        Tg0=np.asarray([val["Tg"] for i,val in enumerate(self.comp)])
        rho0=np.asarray([val["rho0"] for i,val in enumerate(self.comp)])
        K=(rho0[1]*Tg0[1])/(rho0*Tg0)

        K[2]=0.11 if self.molecule2=="indomethacin" else K[2]
        K[2]=0.244 if self.molecule2=="ritonavir" else K[2]
        Tg=(w1*Tg0[0]*K[0]+w2*Tg0[1]*K[1]+w3*Tg0[2]*K[2])/(w1*K[0]+w2*K[1]+w3*K[2])
        Tgnull=(w10*Tg0[0]*K[0]+wnull*Tg0[1]*K[1]+w30*Tg0[2]*K[2])/(w10*K[0]+wnull*K[1]+w30*K[2])

        wreal1=(1-self.wreal)*self.wPolyASD
        wreal2=self.wreal
        wreal3=(1-self.wreal)*(1-self.wPolyASD)
        wspan=np.linspace(0,np.max(wreal2),100)
        wspan1=(1-wspan)*self.wPolyASD
        wspan2=wspan
        wspan3=(1-wspan)*(1-self.wPolyASD)

        self.Tgreal=(wreal1*Tg0[0]*K[0]+wreal2*Tg0[1]*K[1]+wreal3*Tg0[2]*K[2])/(wreal1*K[0]+wreal2*K[1]+wreal3*K[2])
        self.Tgspan=(wspan1*Tg0[0]*K[0]+wspan2*Tg0[1]*K[1]+wspan3*Tg0[2]*K[2])/(wspan1*K[0]+wspan2*K[1]+wspan3*K[2])
        #WL=cs.exp(-rho2II*(Tg-Tgnull)/(Tg0[1]-Tg)*exponent) #exponent for PVPVA with linearized GT 12

        C2=105.45
        
        C1=exponent
        #C3=C1
        #freevolume=C2+C1*(Tg-Tg[0])+C3*(self.T-Tg)
        #WL=10**(-C1*(1/freevolume-1/C2))
        if self.File:
            Tswitch=self.Tswitch
            WL=10**(-(self.T-Tg)/(C2+self.T-Tg)*C1)
            WL=cs.conditional((self.T+C2-Tg)<=0,[WL],1E17)
            C3=self.C3/2.308/self.R
            #C3=self.C3
            C4=-(self.T-Tswitch)/(C2+self.T-Tswitch)*C1
            AR=10**(-C3*(1/(Tg)-1/Tswitch)+C4)
            WL=cs.conditional((Tg)>Tswitch,[WL],AR)
            self.WLF=np.fmin(10**(-(self.T-self.Tgspan)/(C2+self.T-self.Tgspan)*C1)*self.eta0,1E17)
            self.WLF[(self.T+C2-self.Tgspan)<=0]=1E17
            self.AR=10**(-C3*(1/(self.Tgspan)-1/Tswitch)+C4)*self.eta0
            self.WLFreal=np.fmin(10**(-(self.T-self.Tgreal)/(C2+self.T-self.Tgreal)*C1)*self.eta0,1E17)
            self.WLFreal[(self.T+C2-self.Tgreal)<=0]=1E17
            self.ARreal=10**(-C3*(1/(self.Tgreal)-1/Tswitch)+C4)*self.eta0
        else:
            self.WLF=np.exp(-wspan*self.rho0ASD*exponent)
            self.AR=np.exp(-wspan*self.rho0ASD*exponent)
        #z=cs.conditional(0,[x],y)
        #logeta1=np.log10(4E10/eta0)
        #logeta2=np.log10(8E9/eta0)
        #logeta1=np.log10(3E10/eta0)
        #logeta2=np.log10(6E9/eta0)
        #logeta1=np.log10(1E10/eta0)
        #logeta2=np.log10(1E9/eta0)
        #logeta1=np.log10(7E9/eta0)
        #logeta2=np.log10(8E8/eta0)

        #Tg1=48-298.15
        #Tg2=14-298.15 #27
        #C3=(logeta2-logeta1)/(Tg2/self.T-Tg1/self.T)
        #C4=logeta1+C3*Tg1/self.T
        #AR=10**(C3*Tg/self.T+C4)

        #WL=10**(-C1/(C2/(self.T-Tg)+1))
        #WL=10**(-(Tg-Tgnull)/(self.T-Tgnull)*exponent) #2.5 exp 2E3

        #WL=cs.exp(-(1/self.T-1/Tg)*exponent)
        #Tswitch=-20
        
#__________________________________________
        wGGW1=self.rho2IIAnf[self.indJ]
        wGGW2=self.rho2IIGGW[self.indJ]
        activity_fun=cs.Function("activity",[rho2],[activity])
        activity1=activity_fun(wGGW1)
        activity2=activity_fun(wGGW2)

        RV=self.R*self.T*1/self.M2*1/v2

        dummy=cs.MX.sym("dummy")
        initialcond=-rho2+wGGW1+1/v2*cs.log(activity2/activity)*RV/cs.sum1(EJ)
        w2=rho2/(1+rho2)/self.rho0ASD
        #initialcond=-rho2+wGGW1+1/v2_fun(w2)*cs.log(activity2/activity)*RV/cs.sum1(EJ)

        initialdae={"x":dummy,"z":rho2 ,"alg":initialcond,"ode":1}
        F= cs.integrator("F","collocation",initialdae,{'t0':0,'tf':1})
        initialrho2=F(x0=0,z0=(wGGW1+wGGW2)/2)["zf"]
        initialsigma=cs.log(activity2/activity_fun(initialrho2))*RV
        sigmaJ_his=np.zeros((nz+1,nt+1,nJ))
        rho2II_his[nz,:]=initialrho2
        for J in range(nJ):
            sigmaJ_his[nz,:,J]=initialsigma*np.atleast_1d(E0)[J]/np.sum(E0)

        MDF=1/RV*dsigma/deltaz #Mechanical driving force
        ma=cs.gradient(activity,rho2)
        ma_fun=cs.Function("ma_fun",[rho2],[ma])
        jBound=cs.MX.zeros(1)
        j2II=cs.vertcat(jBound,jMS_fun(rho2II,MDF))
        dj2II=self.CDF1O(j2II)
        a2II=activity_fun(rho2II)

        ##Calculate RHS of ODEs
        ma=cs.gradient(activity,rho2)

        #etaWL=cs.fmin((etaJ@WL.T).T,self.etamax)
        etaWL=(etaJ@WL.T).T
        #etaWL=cs.fmin((etaJ@WL.T).T,(etaJ@AR.T).T)
        #tauWL=etaWL/EJ
        drho2dt_hist=cs.sum1(1/etaWL[-1,:].T*sigmaJ[-1,:].T*EJ**2/RV)/(1/a2II[-1]*ma_fun(rho2II[-1])+cs.sum1(EJ)*v2/RV)
        #drho2dt_hist=cs.sum1(1/WL[-1]*1/tauJ*sigmaJ[-1,:].T*EJ/RV)/(1/a2II[-1]*ma_fun(rho2II[-1])+cs.sum1(EJ)*v2_fun(w2II[-1])/RV)
        drhodtNF=cs.vertcat(dj2II/deltaz,drho2dt_hist)
        dsigmaJdt=cs.MX.zeros(nz+1,nJ)
        for i in range(nJ):
            dsigmaJdt[:,i]=-1/etaWL[:,i]*sigmaJ[:,i]*EJ[i]+drhodtNF*v2
            #dsigmaJdt[:,i]=-1/tauJ[i]*sigmaJ[:,i]*1/WL+drhodtNF*v2_fun(w2II)

        sigmaJvec=cs.reshape(sigmaJ,((nz+1)*nJ,1))
        dsigmaJdtvec=cs.reshape(dsigmaJdt,((nz+1)*nJ,1))
        xvec=cs.vertcat(rho2II,sigmaJvec)
        fvec=cs.vertcat(drhodtNF,dsigmaJdtvec)

        x0sigma=cs.reshape(sigmaJ_his[:,0,:]/E0,((nz+1)*nJ,1))
        x0=cs.vertcat(rho2II_his[:,0],x0sigma)
        MDF_fun=cs.Function("MDF_fun",[rho2II,sigmaJ],[MDF])
        return xvec,fvec,x0,MDF_fun

    def SolveODEs(self,x,f,x0,opts,Time):
        dae={"x":x,"t":Time,"ode":f}#,"print_stats":True,"abstol":1E-12}#,max_num_steps":1000"collocation_scheme":"legendre","interpolation_order":2,"number_of_finite_elements":100,"rootfinder_options":{"error_on_fail": False}
        fint=cs.integrator("rho2int","cvodes",dae,opts)
        F=fint(x0=x0)
        return F["xf"]


    def Least(self):

        from scipy.optimize import least_squares
        self.exp_boundary() if not hasattr(self, 'mnull')  else None

        self.PCSAFT(self.p,self.T) if not hasattr(self,'lna2_fun') else None

        def mini(D):
            self.D12=D*1E-13
            self.Mode="NEAT"
            residual=self.Diffusion1D()*1E4
            return residual

        try:
            res_1=least_squares(mini, self.D12*1E13,bounds=(1E-4, 1E3),verbose=2)
        except:
            res_1=least_squares(mini, 1,bounds=(1E-4, 1E3),verbose=2)
        self.D12=res_1['x']*1E-13
        print("Found D12 as: "+str(res_1['x']*1E-13))

    def Cranc(self,Fit="Fit"):

        self.exp_boundary() if not hasattr(self, 'mnull')  else None
        self.PCSAFT(self.p,self.T) if not hasattr(self,'lna2_fun') else None
        mperc=(self.mlist[self.indJ]-self.mlist[self.indJ][0])/(self.mlist[self.indJ][-1]-self.mlist[self.indJ][0])
        X=self.wlist[self.indJ]/(1-self.wlist[self.indJ])
        mperc=(X-X[0])/(X[-1]-X[0])
        def Cranc1(x, D):
            n=20
            Forier=0
            LCranc=2*self.L0
            for cc in range(n):
                Forier=Forier+1/(2*cc+1)**2*np.exp(-((2*cc+1)**2*np.pi**2*D*x)/(LCranc**2))
                mperc=1-8/np.pi**2*Forier
            return mperc

        from scipy.optimize import curve_fit

        if Fit=="Fit":
            popt, pcov = curve_fit(Cranc1, self.tlist[self.indJ], mperc,p0=1E-13)
        else:
            popt, pcov =Fit,0

        mopt=Cranc1(self.tlist[self.indJ],popt)
        Xopt=mopt*(X[-1]-X[0])+X[0]
        wopt=Xopt/(1+Xopt)
        #modelm=Cranc1(self.tlist[self.indJ],popt)*(self.mlist[self.indJ][-1]-self.mlist[self.indJ][0])+self.mlist[self.indJ][0]
        #expm=self.mlist[self.indJ]
        self.wt=wopt
        self.wtref=self.wlist[self.indJ]
        #self.Lchange=self.wlist[self.indJ]
        self.D12=popt



    def LeastMEOS(self,D12True=True,exTrue=True,ETrue=False,tauTrue=True,TswitchTrue=False,C3True=False,Jumps=None):
        from lmfit import Parameters, minimize

        fit_params = Parameters()
        #self.Cranc()

        #GammaJump=float(self.THFaktor_fun(self.wreal[self.nJ]))
        #Dest=1/GammaJump*float(self.D12)#(2*self.L0[self.nJ])**2/self.tlist[self.nJ][-1]

        #Desti=np.log10(Dest/1E-15)
        #print(Dest)
        Desti=np.log10(self.D12/1E-15)
        fit_params.add('D12', value=Desti, min=Desti-2, max=Desti+2,vary=D12True)
        nJ=self.nJ
        fit_params.add('exponent', value=self.exponent, min=0, max=np.inf,vary=exTrue)
        fit_params.add('Tswitch', value=np.log10(self.Tswitch), min=self.T, max=self.T+80,vary=TswitchTrue)
        fit_params.add('C3', value=self.C3, min=0, max=10000,vary=C3True)
        fit_params.add('nJ', value=nJ, min=1, max=10,vary=0)
        [fit_params.add('E0'+str(i), value=np.log10(self.E0/1E9),min=np.log10(1E5/1E9), max=np.log10(1E15/1E9),vary=ETrue) for i in range(int(nJ))]
        [fit_params.add('tau0'+str(i), value=np.log10(self.tau0),min=-8, max=8, vary=tauTrue) for i in range(int(nJ))]
        #[fit_params.add('tau0'+str(i), value=tau0[i], min=tau0[i], max=tau0[i+1]) for i in range(int(nJ))]
        Jumps=self.indJ if Jumps is None else Jumps
        #fit_params.add('Jumps', value=Jumps,min=0,max=1,vary=0)
        self.exp_boundary() if not hasattr(self, 'mnull')  else None

        self.PCSAFT(self.p,self.T) if not hasattr(self,'lna2_fun') else None

        def residual(y):
            #plt.pause(2)
            import matplotlib as mpl
            backend_=mpl.get_backend()
            mpl.use("Agg")
            plt.close('all')
            self.nJ=y["nJ"].value
            self.Tswitch=y["Tswitch"].value
            self.D12=10**y["D12"].value*1E-15
            Earr=np.asarray([10**y["E0"+str(i)].value*1E9 for i in range(nJ)])
            tarr=np.asarray([10**y["tau0"+str(i)].value for i in range(nJ)])
            self.E0=Earr.item() if nJ<=1 else Earr
            self.tau0=tarr.item() if nJ<=1 else tarr
            self.exponent=y["exponent"].value
            self.C3=y["C3"].value
            #print(D12)
            #print(E0)
            #print(tau0)

            #res=np.sum(np.abs(self.Diffusion1DMEOS(*(np.fromiter(y.values(),dtype=float)*np.asarray([1E-15,1E7,1E7,1,1,1])))))
            #res=self.Diffusion1DMEOS(D12=D12,E0=E0,tau0=tau0,nJ=nJ)
            res=[]

            #Jumps=y["Jumps"].value
            for i in np.atleast_1d(Jumps):
                self.indJ=i
                self.Mode="MEOS"
                res=np.hstack((res,self.Diffusion1D()))
                print(res)
            #res=self.Diffusion1D()
            #res=np.sum(np.abs(res))
            #plt.ion()
            mpl.use(backend_)
            return np.nan_to_num(res.astype(float))
        #try:
        #
        #    res_1=least_squares(mini, (self.D12,self.E0,self.E1,self.eta0),bounds=([1E-17,1E3,1E3,1E11], [1E-12,1E13,1E13,1E17]),verbose=2)
        #except:
        out = minimize(residual, fit_params,method="least_squares",ftol=1E-6)
        #fit = residual(out.params)

        out.params['D12'].min=10**out.params['D12'].min*1E-15
        out.params['D12'].max=10**out.params['D12'].max*1E-15
        out.params['D12'].value=10**out.params['D12'].value*1E-15
        out.params['Tswitch'].min=out.params['Tswitch'].min
        out.params['Tswitch'].max=out.params['Tswitch'].max
        out.params['Tswitch'].value=out.params['Tswitch'].value
        for i in range(nJ):
            out.params["E0"+str(i)].min=10**out.params["E0"+str(i)].min*1E9
            out.params["E0"+str(i)].max=10**out.params["E0"+str(i)].max*1E9
            out.params["E0"+str(i)].value=10**out.params["E0"+str(i)].value*1E9
            out.params["tau0"+str(i)].min=10**(out.params["tau0"+str(i)].min)
            out.params["tau0"+str(i)].max=10**(out.params["tau0"+str(i)].max)
            out.params["tau0"+str(i)].value=10**(out.params["tau0"+str(i)].value)
            out.params.add("eta0"+str(i),value=out.params["tau0"+str(i)].value*out.params["E0"+str(i)].value)
        [out.params.add("TgGGW"+str(i),value=val) for i,val in enumerate(self.Tgreal)]
        [out.params.add("wGGW"+str(i),value=val) for i,val in enumerate(self.wreal)]



        import pybroom as br
        import pandas as pd
        dt = br.tidy(out)
        #[dt['kija'+val]=opt.params["kija"+val].value for i,val in enumerate(Solvents)]

        Jumpname="_".join(np.atleast_1d(Jumps).astype(str))
        components="_".join([val["name"] for i,val in enumerate(self.comp)])
        filename=Jumpname+"_"+components+"_fitting.xlsx"
        pathtofilename=os.path.join(os.getcwd(),"LeastMEOS",filename)
        if os.path.exists(pathtofilename):
            with pd.ExcelWriter(filename, engine='openpyxl', mode='a') as writer:
                dt.to_excel(writer,sheet_name=self.DATA_FILE.split("\\")[-1][31:56])
        else:
            with pd.ExcelWriter(filename, engine='openpyxl', mode='w') as writer:
                dt.to_excel(writer,sheet_name=self.DATA_FILE.split("\\")[-1][31:56])

        return
    def CreateDummyExperiment(self):
        RHsteps=self.RHd
        wsteps=self.wd
        L=self.L0d
        tsteps=self.td

        def mdummy(m0,m1,t):
            return m1*(1-np.exp(-t/t[-1]*10))+m0*(np.exp(-t/t[-1]*10))
        tdry=np.linspace(0,300,self.nt*10)
        deltat=[val/(self.nt*10) for i,val in enumerate(tsteps)]
        deltatdry=300/(self.nt*10)
        adry=np.zeros(self.nt*10)
        tsteps2=np.hstack((tdry[-1],tdry[-1]+np.cumsum(tsteps)))
        a_exp=np.asarray([np.ones(self.nt*10)*val for i,val in enumerate(RHsteps)]).flatten()
        t_exp=np.asarray([np.linspace(tsteps2[i],tsteps2[i+1],self.nt*10) for i,val in enumerate(tsteps)]).flatten()
        w0=np.asarray(wsteps)
        rhonull=((1-self.wPolyASD)/self.rho03+self.wPolyASD/self.rho01)**-1
        mnull=rhonull*self.A0*L
        m0=mnull/(1-w0)
        msteps=np.hstack((mnull,m0))
        m_exp=np.asarray([mdummy(msteps[i],msteps[i+1],np.linspace(0,tsteps[i],self.nt*10)) for i,val in enumerate(tsteps)])#.flatten()#np.asarray([msteps[i+1]*(1-np.exp(-np.linspace(0,tsteps[i],self.nt)/tsteps[i]*10))+msteps[i]*np.exp(-np.linspace(0,tsteps[i],self.nt)/tsteps[i]*10) for i,val in enumerate(tsteps)]).flatten()
        for i,val in enumerate(tsteps):
            m_exp[i,-1]=msteps[i+1]
        m_exp=m_exp.flatten()
        mdry=mdummy(np.average(m0),mnull,tdry)#np.average(m0)*(np.exp(-tdry/tdry[-1]*10))+mnull*(1-np.exp(-tdry/tdry[-1]*10))
        t_exp=np.hstack((tdry,t_exp))
        a_exp=np.hstack((adry,a_exp))
        m_exp=np.hstack((mdry,m_exp))*1E6
        w_exp=(m_exp-mnull*1E6)/m_exp
        return a_exp,a_exp,a_exp,t_exp,m_exp
        #set analogously to dvs read
        #we need mnull only to get L
        #Set w0,wGGW,L,RH0,RHGGW
        # We can further apply a list of these values
    def read_excel_file(self,filename):


        start_time = time.time()
        # =============================================================================
        nt=self.nt

        stra='Target Partial Pressure (Solvent A) [%]' if self.solvent=="water" else 'Target Partial Pressure (Solvent B) [%]'
        straa='Actual Partial Pressure (Solvent A) [%]' if self.solvent=="water" else 'Actual Partial Pressure (Solvent B) [%]'
        straaa='Measured Partial Pressure (Solvent A) [%]' if self.solvent=="water" else 'Measured Partial Pressure (Solvent B) [%]'
        strt="Time [minutes]"
        strm="m_Korr[mg]"
        strm2="Mass [mg]"
        start="Time [minutes]"
        try:
            #print("Search for <<"+strm+">>")
            a2_exp,a1_exp,a_exp,t_exp,m_exp=FasterXlrdRead(filename,start,straaa,straa,stra,strt,strm) if self.File==True else self.CreateDummyExperiment()

        except:
            #print("Found <<" +strm2+ ">> instead")
            a2_exp,a1_exp,a_exp,t_exp,m_exp=FasterXlrdRead(filename,start,straaa,straa,stra,strt,strm2) if self.File==True else self.CreateDummyExperiment()

        aa_exp=a2_exp if (a1_exp==np.zeros_like(a1_exp)).all() else a1_exp

        m_exp=m_exp*1E-6
        t_exp=t_exp*60
        # a_exp[a_exp==9.24]=10.0
        # a_exp[a_exp==29.39]=30.0
        # a_exp[a_exp==44.49]=45.0
        # a_exp[a_exp==59.9]=60.0
        # a_exp[a_exp==73.44]=75.0
        # a_exp[a_exp==87.81]=90.0

        #import pdb
        #pdb.set_trace()
        Feuchte, indices=np.sort(np.unique(a_exp,return_index=True))
        #Detect absorbtion and desorption cycles
        dRHdt=np.diff(a_exp)
        indch=np.hstack((1,np.where(dRHdt!=0)[0]+1))
        des=dRHdt[indch-1]<=0
        abso=dRHdt[indch-1]>=0
        nJump=indch.shape[0]
        idxdes=np.where(des)[0]
        #idxabso=np.where(abso)[0]
        indices=np.append(indch,-2) #Anfügen des Endes der Messung
        #indices=indices.astype(int)

        mnull=m_exp[indices[1]] #Masse der Probe vor dem Experiment [mg]
        #w_exp=(m_exp-mnull)/m_exp
         # Prozent in Anteile [-]
        wreal=[]
        wanf=[]
        wrealmittel=[]
        Feuchtereal=[]
        mlist=[]
        tlist=[]
        wlist=[]
        key=[]
        wrealdes=[]
        wanfdes=[]
        wrealmitteldes=[]
        Feuchterealdes=[]
        mlistdes=[]
        tlistdes=[]
        wlistdes=[]
        keydes=[]
        Feuchteactual=[]
        Feuchteactualdes=[]
        Feuchteanf=[]
        Feuchteanfdes=[]
        sratel=[]
        srateldes=[]
        #if File==True else self.read_user()
        def Appending(wreal,wanf,wrealmittel,Feuchtereal,Feuchteactual,Feuchteanf,mlist,tlist,wlist,sratel,key,indices,k,des=False):
                jump=str(a_exp[indices[k]-1])+"_"+str(a_exp[indices[k]]) #if des==False else str(a_exp[indices[k]])+"_"+str(a_exp[indices[k]-1])
                key.append(jump)
                toffset=2 if self.molecule!="polylactid" else 0 #toffset 2 sonst
                toffset=toffset if self.File==True else 0
                mapp=m_exp[indices[k]+toffset:indices[k+1]]
                mapp=mapp #if des==False else -mapp
                tapp=t_exp[indices[k]+toffset:indices[k+1]]

                wapp=(mapp-mnull)/mapp #if des==False else (mapp+mnull)/mapp



                mmax=np.max(mapp)

                mpercent=(mapp-mapp[0])/(mmax-mapp[0]) #indmax befor mpercent is better for small masses 10.05.20

                srate=np.gradient(wapp,tapp)
                srate_smooth=median_filter(srate,50,mode="nearest")
                
                #indmmax=next(i for i,v in enumerate(mpercent-0.995>0) if v) if self.molecule!="polylactid" else -1
                indmmax=-1
                #indmmax=indmmax if (tapp[indmmax]-tapp[0])/60>60 else np.where((tapp-tapp[0])/60>60)[0][0] #-1
                #indmmax=np.flatnonzero((tapp-tapp[0])/60>60)[0]#next(i for i,v in enumerate((tapp-tapp[0])/60>60) if v)
                # try:
                #     indmmax=np.flatnonzero((tapp-tapp[0])/60>180)[0]#next(i for i,v in enumerate((tapp-tapp[0])/60>60) if v)
                # #indmmax=indices[k]+1
                # except:
                #     indmmax=-1#tapp.size
                
                mapp=mapp[0:indmmax]
                tapp=tapp[0:indmmax]
                tapp=(tapp-tapp[0])
                wapp=wapp[0:indmmax]
                srate_smooth=srate_smooth[0:indmmax]

                tapp2, mapp2=interparc(tapp, mapp, nt+1) if self.molecule!="polylactid" else interparc(tapp**(1/2), mapp, nt+1)
                tapp2=tapp2 if self.molecule!="polylactid" else tapp2**2
                wapp2=(mapp2-mnull)/mapp2 #if des==False else (mapp2+mnull)/mapp2
                wapp2=np.fmax(wapp2,1E-4)
                mapp2=mapp2 #if des==False else -mapp2
                tlist.append(tapp2)
                mlist.append(mapp2)
                wlist.append(wapp2) #if des==False else wlist.append(-wapp2+wapp2[0]+wapp2[-1])
                wanf.append(wapp2[0]) #if des==False else wanf.append(wapp2[-1])
                wreal.append(wapp2[-1]) #if des==False else wreal.append(wapp2[0])
                srate2=np.gradient(wapp2,tapp2)
                srate2_smooth=median_filter(srate2,50,mode="nearest")

                wrealmittel.append(0.7*wapp2[-1]+0.3*wapp2[0])
                FFeuchte=np.mean(aa_exp[indices[k]+toffset:indices[k+1]-1])*0.01 #if des==False else np.mean(aa_exp[indices[k-1]+toffset:indices[k]-1])*0.01
                Feuchtean=a_exp[indices[k-1]]*0.01
                Feuchte=a_exp[indices[k]]*0.01 #if des==False else a_exp[indices[k-1]]*0.01
                Feuchtereal.append(Feuchte)
                Feuchteanf.append(Feuchtean)
                Feuchteactual.append(FFeuchte)
                sratel.append(srate2_smooth)
                #plt.plot(tapp,mapp)
                return
        for k in range(1,nJump):
            if all(k!=idxdes):
                Appending(wreal,wanf,wrealmittel,Feuchtereal,Feuchteactual,Feuchteanf,mlist,tlist,wlist,sratel,key,indices,k)
            elif any(k==idxdes) and len(m_exp[indices[k]:indices[k+1]])>0:
                Appending(wrealdes,wanfdes,wrealmitteldes,Feuchterealdes,Feuchteactualdes,Feuchteanfdes,mlistdes,tlistdes,wlistdes,srateldes,keydes,indices,k,des=True)
        self.nHum=len(wreal) if not self.des==True else len(wrealdes)
        #self.nHumdes=len(wrealdes)
        self.dickeys=key if not self.des==True else keydes
        #endhums=[val.split("_")[1] for i,val in enumerate(self.dictkeys)]
        #self.wrealdes=wrealdes#if not self.des==True else keydes
        #self.wanfdes=wanfdes
        self.wrealmittelref=wrealmittel if not self.des==True else wrealmitteldes
        #self.wrealmitteldes=wrealmitteldes
        #self.Feuchterealdes=Feuchterealdes#[1:]
        self.tlist=tlist if not self.des==True else tlistdes
        self.mlist=mlist if not self.des==True else mlistdes
        self.wlist=wlist if not self.des==True else wlistdes
        self.wreal=np.asarray(wreal) if not self.des==True else np.asarray(wrealdes)
        self.wanf=np.asarray(wanf) if not self.des==True else np.asarray(wanfdes)
        self.Feuchtereal=np.asarray(Feuchtereal) if not self.des==True else np.asarray(Feuchterealdes)
        self.Feuchteactual=np.asarray(Feuchteactual) if not self.des==True else np.asarray(Feuchteactualdes)
        self.mnull=mnull
        self.Feuchteanf=np.asarray(Feuchteanf) if not self.des==True else np.asarray(Feuchteanfdes)
        self.sratel=sratel if not self.des==True else srateldes
        Feuchteges=np.hstack((Feuchtereal,Feuchterealdes))
        wges=np.hstack((wreal,wrealdes))
        wges=wges[Feuchteges!=0]
        Feuchteges=Feuchteges[Feuchteges!=0]


        self.Feuchteiso,idxunique=np.unique(Feuchteges,True)
        self.wiso=np.asarray([np.average(wges[Feuchteges==val]) for i,val in enumerate(self.Feuchteiso)])

        # If Absorbtion and Desorption have differences do not take the average between them even if its the same RH
        Feuchteun,idxun=np.unique(self.Feuchtereal,True)
        wun=np.asarray([np.average(np.asarray(self.wreal)[self.Feuchtereal==val]) for i,val in enumerate(Feuchteun)])
        self.wiso=np.asarray([np.average(wun[Feuchteun==val]) if len(wun[Feuchteun==val])>0 else np.average(wges[Feuchteges==val]) for i,val in enumerate(self.Feuchteiso)])

        # If the actual RH is required we take it instead
        Feuchteactualges=np.hstack((Feuchteactual,Feuchteactualdes))
        self.Feuchtereal=self.Feuchteactual if self.Actual==True else self.Feuchtereal
        self.Feuchteiso=np.asarray([np.average(self.Feuchtereal[idxun][Feuchteun==val]) if len(self.Feuchtereal[idxun][Feuchteun==val])>0 else np.average(Feuchteactualges[Feuchteges==val]) for i,val in enumerate(self.Feuchteiso)]) if self.Actual==True else self.Feuchteiso

        #wiso=[]
        #for i,val in enumerate(self.Feuchteiso):
        #    wiso.append(np.average(wges[Feuchteges==val])])
        #if Feuchtereal==Feuchterealdes
        #Feuchteun=np.unique(self.Feuchtereal)
        #Feuchteundes=np.unique(Feuchterealdes)
        #wun=np.asarray([np.average(np.asarray(self.wreal)[self.Feuchtereal==val]) for i,val in enumerate(Feuchteun)])
        #wundes=np.asarray([np.average(np.asarray(wrealdes)[Feuchterealdes==val]) for i,val in enumerate(Feuchteundes)])
        #wisoun=np.hstack((wun,wundes))
        #self.wiso=np.asarray(wun[Feuchteun==val]) if len(wun[Feuchteun==val])>0 else np.average(wges[Feuchteges=val]) for i,val in enumerate(self.Feuchteiso)])
        #self.wiso=np.asarray([np.average(wges[Feuchteges==val]) for i,val in enumerate(self.Feuchteiso)])
        #Feuchteundes=np.unique(Feuchterealdes)
        #self.wiso=np.asarray(wiso)
        #self.wiso=np.asarray([np.average(wges[Feuchteges==val]) if wges[Feuchteges==val]>1 for i,val in enumerate(self.Feuchteiso)])
        print("Reading Excel-File took--- %s seconds ---" % (time.time() - start_time))
    def read_excel_Sotax(self,filename):
        from UVVIs_auslesen import Sotax
        Zeit,Signal,m0=Sotax(filename)
        msol=703
        mw=Signal*m0
        ww=mw/(mw+m0)
        self.RHd=np.asarray([0,1])
        self.wd=np.asarray([0,w[-1]])
        self.L0d=self.m0/(self.rh0ASD*self.A0)
        self.td=np.asarray([60,Zeit[-1]])
        self.CreateDummyExperiment()
        self.tlist[1]=Zeit
        self.mlist[1]=Signal*m0

        #self.wiso=np.asarray([0,ww])
        #self.nHum=1
        #self.dickeys=np.asarray(["0-100"])
        #self.wrealmittelref=0.7*self.wiso
        #self.tlist=Zeit
        #self.mlist=ww*m0
        #self.wlist=1-Signal
        #self.wreal=ww
        #self.wanf=np.asarray(0)
        #self.mnull=m0

    def PCSAFT(self,p,T):
        if self.SAFT==True:
            def getplane(wPolyASD):

                wPolyASDstr=str(round(wPolyASD*100)/100) if not int(wPolyASD)==round(wPolyASD*100)/100 else str(int(wPolyASD))
                molecule1=self.molecule
                molecule2=self.molecule2 if hasattr(self,"molecule2") else self.molecule
                solvent=self.solvent
                filename="_".join(["Isotherm","wpF",wPolyASDstr,molecule1,solvent,molecule2])
                pathname=os.path.join(os.getcwd(),"PyCSAFTSheets",filename)
                temp=self.wPolyASD
                self.wPolyASD=wPolyASD

                self.Recalculate_Isotherm(p,T) if not os.path.isfile(pathname+"_SAFT.csv") else None
                self.wPolyASD=temp
                strx,stry,strz,strq,strsuc,strkris,strrho0,strv1,strx1="mui1","wi1","RH0","TH0","success0","mui2","rho0","vi1","xi1"


                sheet1=sheet(pathname+"_SAFT.csv")
                # sheet1=sheet(pathname+"_Flory.csv")
                sheet2=sheet(pathname+"_NET.csv")
                muxwSAFT,wwSAFT,RHSAFT,THwSAFT,sucSAFT,muxaSAFT,rhoSAFT,v1SAFT,x1SAFT=sheet1.getrows(strx,stry,strz,strq,strsuc,strkris,strrho0,strv1,strx1)
                muxwNET,wwNET,RHNET,THwNET,sucNET,muxaNET,rhoNET,v1NET,x1NET=sheet2.getrows(strx,stry,strz,strq,strsuc,strkris,strrho0,strv1,strx1)
                waNET=(1-self.wPolyASD)*(1-wwNET)
                waSAFT=(1-self.wPolyASD)*(1-wwSAFT)
                wpNET=self.wPolyASD*(1-wwNET)
                wpSAFT=self.wPolyASD*(1-wwSAFT)

                vpSAFT,vwSAFT,vaSAFT=self.convert_fraction(wpSAFT/self.rho01,wwSAFT/self.rho02,waSAFT/self.rho03)
                vpNET,vwNET,vaNET=self.convert_fraction(wpNET/self.rho01,wwNET/self.rho02,waNET/self.rho03)


                #connectorSAFT=(1-x1SAFT)
                #connectorNET=(1-x1SAFT)

                connectorSAFT=(1-x1SAFT)/(1-wwSAFT)
                connectorNET=(1-x1NET)/(1-wwNET)
                #connectorSAFT=(1-x1SAFT)/(1-vwSAFT)
                #connectorNET=(1-x1NET)/(1-vwNET)
                THwSAFT=THwSAFT*connectorSAFT
                THwNET=THwNET*connectorNET

                def SplineCorrection(x,y,suc):
                    return InterpolatedUnivariateSpline(x[suc==1],y[suc==1])(x)
                wwSAFT=SplineCorrection(RHSAFT,wwSAFT,sucSAFT)
                wwNET=SplineCorrection(RHNET,wwNET,sucNET)

                THwSAFT=SplineCorrection(RHSAFT,THwSAFT,sucSAFT)
                THwNET=SplineCorrection(RHNET,THwNET,sucNET)


                muxwSAFT=SplineCorrection(RHSAFT,muxwSAFT,sucSAFT)
                muxwNET=SplineCorrection(RHNET,muxwNET,sucNET)

                muxaSAFT=SplineCorrection(RHSAFT,muxaSAFT,sucSAFT)
                muxaNET=SplineCorrection(RHNET,muxaNET,sucNET)

                v1SAFT=SplineCorrection(RHSAFT,v1SAFT,sucSAFT)
                v1NET=SplineCorrection(RHNET,v1NET,sucNET)

                rhoSAFT=SplineCorrection(RHSAFT,rhoSAFT,sucSAFT)
                rhoNET=SplineCorrection(RHNET,rhoNET,sucNET)

                self.THFaktorNET_fun=InterpolatedUnivariateSpline(np.hstack((0,wwNET,1)),np.hstack((1,THwNET,1)))
                self.THFaktorSA_fun=InterpolatedUnivariateSpline(np.hstack((0,wwSAFT[:-1],1)),np.hstack((1,THwSAFT[:-1],1)))
                below=wwNET>wwSAFT
                above=wwNET<=wwSAFT
                ww=np.hstack((wwNET[below],wwSAFT[above])) if self.NET else wwSAFT
                muxw=np.hstack((muxwNET[below],muxwSAFT[above])) if self.NET else muxwSAFT
                #muxa=np.hstack((muxaNET[below],muxaSAFT[above])) if self.NET else muxaSAFT
                muxa=muxaSAFT # only water chemical potenitial 
                THw=np.hstack((THwNET[below],THwSAFT[above])) if self.NET else THwSAFT
                rho=np.hstack((rhoNET[below],rhoSAFT[above])) if self.NET else rhoSAFT
                v1=np.hstack((v1NET[below],v1SAFT[above])) if self.NET else v1SAFT
                RH=RHSAFT
                print(THw)
                return ww,THw,RH,muxw,muxa,rho,v1
            if self.Mode=="Kris" and not self.ideal:

                wPolyASD=self.wPolyASD
                wPolyASDeven=np.ceil(wPolyASD*10)/10
                wPolyASDevenvec=np.arange(wPolyASDeven,1.01,0.02)
                wPolyASDvec=np.hstack((wPolyASD,wPolyASDevenvec)) if wPolyASDeven!=wPolyASD else wPolyASDevenvec
                alpha=(wPolyASDvec-wPolyASD)/wPolyASDvec
                #wwSIMexp=InterpolatedUnivariateSpline(self.alphavec[self.alphavec>=0],self.wwSIMraw[self.alphavec>=0])(alpha)
                #wPolyASDvec=np.ones(9)
                muxws=[]
                muxas=[]
                wws=[]
                wwtemps=[]
                RHtemps=[]
                THwtemps=[]
                wwvec=np.linspace(0,0.4,1000)

                for i,val in enumerate(wPolyASDvec):
                    wwtemp,THwtemp,RHtemp,muxwtemp,muxatemp,rho,vw=getplane(val)
                    #wwtemp_fun=InterpolatedUnivariateSpline(RHtemp,wwtemp,k=1,ext=3)
                    #wwtemp2=wwtemp*wwSIMexp[i]/wwtemp_fun(self.RHraw)
                    #wwtemp2=wwtemp_fun(sel)
                    
                    muxwtemp2=InterpolatedUnivariateSpline(wwtemp,muxwtemp,k=1,ext=3)(wwvec)
                    muxatemp2=InterpolatedUnivariateSpline(wwtemp,muxatemp,k=1,ext=3)(wwvec)
                    muxws.append(muxwtemp2)
                    muxas.append(muxatemp2)
                    wws.append(wwvec)
                    wwtemps.append(wwtemp)
                    RHtemps.append(RHtemp)
                    THwtemps.append(THwtemp)
                ww=wwtemps[0]
                RH=RHtemps[0]
                THw=THwtemps[0]
                muxws=np.asarray(muxws)
                # currentpath = os.getcwd()
                # foldername = "PyCSAFTSheets"
                # tablename_1 = "sle_napvp"
                # filename_1 ="_".join([tablename_1]+excelstr)+".xlsx"
                # pathname_1 = os.path.join(currentpath,foldername,filename_1)
                # pure, kij = get_pcpar.get_par(excelstr,T=temp)
                # napvp = Mixture(*pure,dikij=kij)
                # napvp.pH2OLV = np.asarray([1.013E5])

                # result_napvp_sle = [napvp.SLE(psys=1.013E5,T=temp,wwASD=0)] #DB Ich dachte, dass sich im ternären das chem. Pot ändern muss da sich die Löslichkeit mit der Wasserkonzentration ändern!


                #self.comp[2][]

                deltaHSL=self.comp[2]["deltaHSL"]
                Tm=self.comp[2]["Tm"]
                cpSL=self.comp[2]["cpSL"]

                T=self.T
                R=self.R

                SLE=-deltaHSL/(R*T)*(1-T/Tm)+cpSL/R*(Tm/T-1-cs.log(Tm/T))
                API=Mixture(self.comp[1],self.comp[2])
                API.PCSAFT(self.p,self.T)


                mupure=API.Pure(psys=self.p,T=self.T)["mui"][1]#-69.64346586
                muaSLE=mupure+SLE
                self.muaSLE=muaSLE
                #print(muaSLE)
                muxas=np.fmax(np.asarray(muxas),muaSLE)-muaSLE
            else:
                ww,THw,RH,muxw,muxa,rho,vw=getplane(self.wPolyASD)

        else:
            ww=np.hstack((1E-6,self.wiso))
            RH=np.hstack((1E-4,self.Feuchteiso))


            #try:
            #import pdb
            #pdb.set_trace()
            RH_fun=InterpolatedUnivariateSpline(ww,RH,k=1)
            #except:
            #RH_fun=InterpolatedUnivariateSpline(ww,RH,k=1)
            ww=np.linspace(1E-6,np.max(ww),100)
            Xw=ww/(1+ww)
            #rho0ASD=self.idealdensity(self.wPolyASD/self.rho01,(1-self.wPolyASD)/self.rho03)
            #rhow=rho0ASD*Xw
            v2id=1/self.rho02
            v1id=1/self.rho01
            v3id=1/self.rho03
            vid=v1id*(1-ww)*self.wPolyASD+v3id*(1-ww)*(1-self.wPolyASD)+v2id*ww
            vex=0
            v=vid+vex
            rho=1/v
            #vw=np.gradient(v,ww)
            vw=v2id*np.ones_like(ww)

            RH=RH_fun(ww)
            x1,x2,x3=self.convert_fraction((1-ww)*self.wPolyASD/self.M1,ww/self.M2,(1-ww)*(1-self.wPolyASD)/self.M3)
            #muxw=np.log(RH/x2)
            #THw=np.gradient(muxw)/np.gradient(np.log(x2))
            muxw=np.log(RH)
            THw=np.gradient(muxw)/np.gradient(np.log(ww))
            wwSAFT,wwNET=ww,ww
            THwSAFT,THwNET=THw,THw
            self.THFaktorNET_fun=InterpolatedUnivariateSpline(np.hstack((0,wwNET,1)),np.hstack((1,THwNET,1)))
            self.THFaktorSA_fun=InterpolatedUnivariateSpline(np.hstack((0,wwSAFT[:-1],1)),np.hstack((1,THwSAFT[:-1],1)))

        #plt.plot(RHSAFT,ww,'ko')
        #plt.plot(RHSAFT,wwSAFT,'rx')
        #plt.plot(RHNET,wwNET,'bx')

        #lna2_fun=cs.interpolant('LUT','linear',[ww],muxw)
        if self.Mode=="Kris" and self.ideal==0 and self.SAFT==True:
            muxwvec=muxws.flatten()
            muxavec=muxas.flatten()

            self.muxwmax=np.max(muxwvec)
            self.muxwmin=np.min(muxwvec)
            lna2_fun=cs.interpolant("LUT","linear",[wwvec,alpha],muxwvec)
            deltamu_fun=cs.interpolant("LUT","linear",[wwvec,alpha],muxavec)
            #WW,ALPHA=np.meshgrid(wwvec,alpha)
            #from mpl_toolkits.mplot3d import Axes3D
            #ig = plt.figure()
            #ax = plt.axes(projection="3d")
            #ax.scatter(WW,ALPHA,muxas)
            #ax.scatter(WW,ALPHA,muxws)
            #plt.show()
            self.deltamu_fun=deltamu_fun
            #
        else:
            lna2_fun=cs.interpolant('LUT','linear',[ww],muxw)

        #try:
        RH_fun=InterpolatedUnivariateSpline(ww,RH,k=1)
        ww_fun=InterpolatedUnivariateSpline(RH,ww,k=1)
        #except:
        #    RH_fun=InterpolatedUnivariateSpline(ww,RH,k=1)
        #    ww_fun=InterpolatedUnivariateSpline(RH,ww,k=1)
        self.RH_fun=RH_fun
        self.ww_fun=ww_fun
        THFaktor_fun=InterpolatedUnivariateSpline(np.hstack((0,ww[:-1],1)),np.hstack((1,THw[:-1],1)),k=1)
        self.THFaktor_fun=THFaktor_fun
        self.lna2_fun=lna2_fun
        #____________________
        v2_fun=cs.interpolant("LUT","linear",[ww],vw)
        rho_fun=cs.interpolant("LUT","linear",[ww],rho)
        #print(rho)
        #print(vw)
        self.v2_fun=v2_fun
        self.rho_fun=rho_fun
        #____________________
        return lna2_fun,lna2_fun,THFaktor_fun,RH_fun

    def Recalculate_Isotherm(self,p,T):
        solvent=self.solvent
        molecule1=self.molecule
        molecule2=self.molecule2 if hasattr(self,"molecule2") else self.molecule
        pure, kij,ksw=get_par([molecule1,solvent,molecule2])
        if self.NET==True:
            #kij["pvpva64water"]=-.134
            #kij["waterpvpva64"]=-.134
            kij["pvpva64water"]=-.128
            kij["waterpvpva64"]=-.128
            kij["pvpwater"]=-0.128
            kij["waterpvp"]=-0.128
            #kij["waterindomethacin"]=-0.025
            #kij["indomethacinwater"]=-0.025
        kij["waterindomethacin"]=-0.022
        kij["indomethacinwater"]=-0.022
        kij["waterritonavir"]=-0.0605
        kij["ritonavirwater"]=-0.0605

        Film=Mixture(*pure,wPolyASD=self.wPolyASD,dikij=kij,diksw=ksw)
        Film.Isotherm(self.wPolyASD,T=T,niso=self.n,NET=self.NET)
    def CalcTerDiffcoeff(self,Cranc=True,Plot=False):
        self.exp_boundary() if not hafsattr(self, 'mnull')  else None
        cwd=os.getcwd()
        pathdiffcoeff1=os.path.join(cwd,"LeastFit","Fit",self.molecule+".xlsx")
        pathdiffcoeff2=os.path.join(cwd,"LeastFit","Fit",self.molecule2+".xlsx")
        wPolyASDvec=np.linspace(0,1,21)
        pathdiffcoeffs=[os.path.join(cwd,"LeastFit","Fit","_".join([self.molecule,self.molecule2,str(val)])+".xlsx") for i,val in enumerate(wPolyASDvec)]
        pathdiff=[val for i,val in enumerate(pathdiffcoeffs) if os.path.isfile(val)]
        wPolyvec=[wPolyASDvec[i] for i,val in enumerate(pathdiffcoeffs) if os.path.isfile(val)]
        def read_diffcoeff(filename,molecule):
            Lit=pd.read_excel(filename).dropna()
            DF=Lit["DFickave/m/s^2 0"].values if not Cranc else Lit["DCrancave/m/s^2 0"].values
            RH=Lit["RHave/- 0"].values
            wwm=Lit["w2ave/- 0"].values
            ww=Lit["w2barave/- 0"].values

            allmethods=self.__dict__.keys()
            #Get Binary THFaktor___________________________________
            tempself=[getattr(self,val) for i,val in enumerate(allmethods)]
            self.molecule=molecule
            self.molecule2=molecule
            self.wiso=wwm
            self.Feuchteiso=RH
            self.wPolyASD=1
            wspan=np.linspace(0,np.max(ww),100)
            self.PCSAFT(self.p,self.T)
            TH=self.THFaktor_fun(ww)
            THspan=self.THFaktor_fun(wspan)
            fig1,ax1=plt.subplots()
            ax1.plot(wspan,THspan)
            #wspan=np.linspace(0,self.wrealmittelref)
            #_______ reset all changes made to the class
            [setattr(self,val,tempself[i]) for i,val in enumerate(allmethods)]

            D=DF/TH
            #Glass Transition distance Tapparent
            Tg0=np.asarray([val["Tg"] for i,val in enumerate(self.comp)])
            rho0=np.asarray([val["rho0"] for i,val in enumerate(self.comp)])
            q=np.asarray([0,0,0])
            if self.molecule2=="indomethacin":
                kfitindo=0.11
                rhofit=(rho0[1]*Tg0[1])/(kfitindo*Tg0[2])
                rho0[2]=rhofit
            if self.molecule2=="ritonavir":
                kfitindo=0.244
                rhofit=(rho0[1]*Tg0[1])/(kfitindo*Tg0[2])
                rho0[2]=rhofit
            #if self.molecule=="pvp":
            #    kfitindo=0.33
            #    rhofit=(rho0[1]*Tg0[1])/(kfitindo*Tg0[0])
            #    rho0[0]=rhofit
            #from TgGordnonTaylor import TG2
            #print(self.molecule)
            #print(molecule)
            #Tggt=self.Tg
            from Pylomer.PyGT import Tggt
            #TgMol=self.T-TG2(ww,0,Tg0,rho0) if self.molecule in filename else self.T-TG2(ww,1,Tg0,rho0)
            #TgMol=(TgMol-np.min(TgMol))/(abs(np.min(TgMol))-np.min(TgMol))
            w2=np.asarray(ww)
            w10=np.ones_like(w2)
            w30=1-w10
            wnull=np.zeros_like(w2)

            w1=(1-w2)*w10
            w3=(1-w2)*w30
            wdry1=np.asarray([w10,wnull,wnull])
            wdry2=np.asarray([wnull,wnull,w10])
            wwet1=np.asarray([w1,w2,w3])
            wwet2=np.asarray([w3,w2,w1])
            #Tgbinmax=TG2(0,0,Tg0,rho0) if self.molecule in filename else TG2(0,1,Tg0,rho0)
            #Tgbin=TG2(ww,0,Tg0,rho0) if self.molecule in filename else TG2(ww,1,Tg0,rho0)

            Tgbinmax=Tggt(wdry1.T,rho0,Tg0,q) if self.molecule in filename else Tggt(wdry2.T,rho0,Tg0,q)
            Tgbin=Tggt(wwet1.T,rho0,Tg0,q) if self.molecule in filename else Tggt(wwet2.T,rho0,Tg0,q)
            Psibin=(Tgbinmax-Tgbin)/(Tgbinmax-self.T)
            Psispan=np.linspace(0,np.max(Psibin),100)
            #Psibin=-Tgbin/self.T
            #Psibin=self.T+Tgbinmax-Tgbin



            #Dave=np.mean(D)
            from scipy.interpolate import PchipInterpolator

            Dintw=PchipInterpolator(ww,D)(wspan)
            Dintpsi=PchipInterpolator(Psibin,D)(Psispan)

            #Dfunw=cs.interpolant('LUT','linear',[wspan],Dintw)
            #Dfun=cs.interpolant('LUT','linear',[Psispan],Dintpsi)

            Dfunw=cs.interpolant('LUT','linear',[ww],D)
            Dfun=cs.interpolant('LUT','linear',[Psibin],D)



            Dspanw=Dfunw(wspan).full().T[0]
            Dspan=Dfun(Psispan).full().T[0]
            #fig2,ax2=plt.subplots()
            #ax2.plot(wspan,Dspanw)
            #ax2.plot(ww,D,'kx')
            #fig3,ax3=plt.subplots()
            #ax3.plot(Psispan,Dspan)
            #ax3.plot(Psibin,D,'kx')

            #Hier entkommentieren wenn Readdiffcoef
            Plotlist([ww,Psibin],[D,D],[wspan,Psispan],[Dspanw,Dspan],Origin=False,xla="w2/-",yla="D/m^2/s",filename=os.path.basename(filename)) if Plot  else None

            #TgASDmax=TG2(0,1-self.wPolyASD,Tg0,rho0)
            #TgASD=TG2(np.asarray(self.wrealmittelref),1-self.wPolyASD,Tg0,rho0)
            w2=np.asarray(self.wrealmittelref)
            w10=np.ones_like(w2)*self.wPolyASD
            w30=1-w10
            wnull=np.zeros_like(w2)
            w1=(1-w2)*w10
            w3=(1-w2)*w30
            wmax=np.asarray([w10,wnull,w30])
            wASD=np.asarray([w1,w2,w3])
            #q=np.asarray([-600,0,0]) if self.molecule2=="indodmethacin" else np.asarray([0,0,0])
            q=np.asarray([0,0,0])
            TgASDmax=Tggt(wmax.T,rho0,Tg0,q)
            TgASD=Tggt(wASD.T,rho0,Tg0,q)
            PsiASD=(TgASDmax-TgASD)/(TgASDmax-self.T)
            #PsiASD=-TgASD/self.T
            #PsiASD=self.T+TgASDmax-TgASD
            # TgASD=TgASD[self.indJ]
            #import pdb

            Dave=Dfun(PsiASD[self.indJ]).full()[0][0]# if self.wrealmittelref[self.indJ]>ww[0] else D[0]#Changed 18.05 for prediction of pure substances

            #Dave=Dave#np.fmin(Dave,np.max(D))

            #print("Calculated D12 as "+str(Dave))
            #Dave=np.mean(D)
            return Dave,wspan,Psispan,THspan,Dspanw,Dspan,ww,Psibin,TH,D,Dfun,w2,PsiASD
        D12,wspan12,Psispan12,THspan12,Dspanw12,Dspan12,ww12,Psibin12,TH12,Dvec12,Dfun12,wASD12,PsiASD12= read_diffcoeff(pathdiffcoeff1,self.molecule) 
        D23,wspan23,Psispan23,THspan23,Dspanw23,Dspan23,ww23,Psibin23,TH23,Dvec23,Dfun23,wASD23,PsiASD23= read_diffcoeff(pathdiffcoeff2,self.molecule2) 

        def read_diffcoeff_Fits(filename,wPolyASD,D12_fun,D23_fun):
            Lit=pd.read_excel(filename).dropna()
            DF=Lit["DStefanave/m/s^2 0"].values
            RH=Lit["RHave/- 0"].values
            wwm=Lit["w2ave/- 0"].values
            ww=Lit["w2barave/- 0"].values
            w2=ww
            w10=np.ones_like(w2)*wPolyASD
            w30=1-w10
            wnull=np.zeros_like(w2)
            w1=(1-w2)*w10
            w3=(1-w2)*w30
            wmax=np.asarray([w10,wnull,w30])
            wASD=np.asarray([w1,w2,w3])

            q=np.asarray([0,0,0])
            Tg0=np.asarray([val["Tg"] for i,val in enumerate(self.comp)])
            rho0=np.asarray([val["rho0"] for i,val in enumerate(self.comp)])
            q=np.asarray([0,0,0])
            if self.molecule2=="indomethacin":
                kfitindo=0.11
                rhofit=(rho0[1]*Tg0[1])/(kfitindo*Tg0[2])
                rho0[2]=rhofit
            if self.molecule2=="ritonavir":
                kfitindo=0.244
                rhofit=(rho0[1]*Tg0[1])/(kfitindo*Tg0[2])
                rho0[2]=rhofit
            from Pylomer.PyGT import Tggt
            TgASDmax=Tggt(wmax.T,rho0,Tg0,q)
            TgASD=Tggt(wASD.T,rho0,Tg0,q)
            Psiss=(TgASDmax-TgASD)/(TgASDmax-self.T)

            #x1FEED,x2FEED,x3FEED=self.convert_fraction(wPolyASD/self.M1,0,(1-wPolyASD)/self.M3)
            w1FEED,w2FEED,w3FEED=wPolyASD,0,(1-wPolyASD)
            #v1FEED,v2FEED,v3FEED=self.convert_fraction(wPolyASD/self.rho01,0,(1-wPolyASD)/self.rho03)
            #DWASDFEED=(x1FEED/D12_fun(Psiss)+x3FEED/D23_fun(Psiss))**-1 # 19.08.20 selbe Ergebnisse wie bei Leusmann für PVPIND 80 TOP
            Psivec=np.linspace(0,np.max(Psiss))
            #DWASDFEED=(v1FEED/D12_fun(Psiss)+v3FEED/D23_fun(Psiss))**-1
            #DWASDvec=(v1FEED/D12_fun(Psivec)+v3FEED/D23_fun(Psivec))**-1
            DWASDFEED=(w1FEED/D12_fun(Psiss)+w3FEED/D23_fun(Psiss))**-1
            DWASDvec=(w1FEED/D12_fun(Psivec)+w3FEED/D23_fun(Psivec))**-1

            DWASDFEED=np.asarray(DWASDFEED).T[0]
            DWASDvec=np.asarray(DWASDvec).T[0]
            return DF,DWASDFEED,Psiss,DWASDvec,Psivec
        Fits=[read_diffcoeff_Fits(val,wPolyvec[i],Dfun12,Dfun23) for i,val in enumerate(pathdiff)]
        DFits,DSIMs,PsiFits,DWASDvecs,Psivecs=list(zip(*Fits))
        #DASD,wspanASD,PsispanASD,THspanASD,DspanwASD,DspanASD,wwASD,PsibinASD,THASD,DvecASD,Dfun23,wASD23,PsiASD23= read_diffcoeff(pathdiffcoeff2,self.molecule2) if os.path.isfile(pathdiffcoeff2) else self.D12

        D23_fun=Dfun23#InterpolatedUnivariateSpline(Psibin23,Dvec23,ext=3,k=1)
        D12_fun=Dfun12#InterpolatedUnivariateSpline(Psibin12,Dvec12,ext=3,k=1)
        Psis=np.sort(np.hstack((Psibin12,Psibin23)))
        wws=np.sort(np.hstack((ww12,ww23)))
        Psiss=np.sort(np.hstack((PsiASD12,PsiASD23)))#PsiASD12#Psis#Psibin12#np.linspace(np.min(Psis),np.max(Psis),100)
        wwss=np.sort(np.hstack((wASD12,wASD23)))#wASD12#wws#ww12#np.linspace(np.min(wws),np.max(wws),100)
        Psiss=PsiASD12#Psispan23
        wwss=wASD12
        #self.D12fun=D12fun
        #self.D23fun=D23fun
        #self.PCSAFT(self.p,self.T,self.n)

        x1FEED,x2FEED,x3FEED=self.convert_fraction(self.wPolyASD/self.M1,0,(1-self.wPolyASD)/self.M3)
        w1FEED,w2FEED,w3FEED=self.wPolyASD,0,(1-self.wPolyASD)
        #v1FEED,v2FEED,v3FEED=self.convert_fraction(self.wPolyASD/self.rho01,0,(1-self.wPolyASD)/self.rho03)
        #DWASDFEED=(x1FEED/D12+x3FEED/D23)**-1 # 19.08.20 selbe Ergebnisse wie bei Leusmann für PVPIND 80 TOP
        #DWASDFEED=(v1FEED/D12+v3FEED/D23)**-1
        DWASDFEED=(w1FEED/D12+w3FEED/D23)**-1
     
        #DWFEED=(x1FEED/D12_fun(Psiss)+x3FEED/D23_fun(Psiss))**-1
        #DWFEED=(x1FEED/D12_fun(Psiss).full().T[0]+x3FEED/D23_fun(Psiss).full().T[0])**-1
        #DWFEED=(v1FEED/D12_fun(Psiss).full().T[0]+v3FEED/D23_fun(Psiss).full().T[0])**-1
        DWFEED=(w1FEED/D12_fun(Psiss).full().T[0]+w3FEED/D23_fun(Psiss).full().T[0])**-1
        #fig4,ax4=plt.subplots()
        #ax4.plot(Psiss,DWFEED,'kx')
        filename=os.path.basename(pathdiffcoeff1).split(".")[0]+"_"+os.path.basename(pathdiffcoeff2).split(".")[0]+"_"+str(self.wPolyASD)
        #wpred=self.ww_fun(self.Feuchtereal)
        #wmittelpred=wpred[1:]*0.7+wpred[:-1]*0.3
        THASD=self.THFaktor_fun(self.wrealmittelref[self.indJ]) # hier wird die gemessene konzentration eingesetzt. Wenn endpoint sollte hier die predictete eingesetzt werden
        #THASD=self.THFaktor_fun(wmittelpred[self.indJ]) # das ändert nicht den PLotdiff plot aber die Predctions
        THWFEED=self.THFaktor_fun(wwss)
        DWASDFEED=DWASDFEED*THASD #if not Cranc else DWASDFEED
        #import pdb
        #pdb.set_trace()
        Plotlist([Psibin12,Psibin23,Psiss]+list(PsiFits),[Dvec12,Dvec23,DWFEED]+list(DFits),[Psispan12,Psispan23,Psiss]+list(Psivecs),[Dspan12,Dspan23,DWFEED]+list(DWASDvecs),Origin=self.Origin,xla="w2/-",yla="D/m^2/s",filename=filename) if Plot  else None
        #if self.Mode=="Kris":
        #    wPolyASDsym=cs.MX.sym("wPolyASDsym")
        #    x1FEED,x2FEED,x3FEED=self.convert_fraction(wPolyASDsym/self.M1,0,(1-wPolyASDsym)/self.M3)
        #    DWASDFEED=(x1FEED/D12+x3FEED/D23)**-1
        #    DWASDFEED=cs.Function('LUT','linear',[wPolyASDsym],[DWASDFEED])
        self.D12=DWASDFEED
        return DWASDFEED

    @staticmethod
    def averaging(a):
        b=(a[:-1]+a[1:])/2#arithmetic

        #b[1:]=b[1:]*2*9/16-1/16*(a[:-2]+a[2:]) #second order
        #b=(1/a[:-1]+1/a[1:])**-1 #harmonic
        #b[-1]=a[-1]#*1+0*a[-1] #Edge of Last Volumeelement must also be dry at t0
        return b
    @staticmethod
    def CDF1O(a):
        b=(a[:-1]-a[1:]) #first order
        #b[1:]=b[1:]*4/3-2/12*(a[:-2]-a[2:]) #second order
        #b[2:]
        return b
    @staticmethod
    def averaging2D(a,axis):
        if axis==0:
            b=(a[:-1,:]+a[1:,:])/2
        elif axis==1:
            b=(a[:,:-1]+a[:,1:])/2
        elif axis==2:
            b=(a[:-1,:]+a[1:,:])/2
            b=(b[:,:-1]+b[:,1:])/2
        return b
    @staticmethod
    def convert_fraction(*args):
        return tuple(j/sum(args) for i,j in enumerate(args))
    def idealdensity(self,*args):
        outs=self.convert_fraction(*args)
        return outs[0]/args[0]
    @staticmethod
    def Tg(wi,rhoi,Tgi,q=0,idx=1):
        #ki=rhoi[idx]*Tgi[idx]/(rhoi*Tgi)
        nc=rhoi.shape[0]
        qmat=np.zeros((nc,nc))
        qmat[np.triu_indices(nc, k=1)]=q
        Ideal=np.sum(wi*1/rhoi,1)/np.sum(wi*1/rhoi/Tgi,1)
        #Ideal=np.sum(Tgi*wi*ki,1)/np.sum(wi*ki,1)
        Excess=np.asarray([np.sum(np.prod(np.meshgrid(wi[i,:],wi[i,:]),axis=0)*qmat) for i,val in enumerate(wi[:,0])])
        return Ideal+Excess




#Film1=Film()
if __name__=="__main__":
    pure,kij,ksw,ksw=get_par(["pvpva64","water","pvpva64"])
    pol,sol,api=pure
    plt.close('all')

    filename=""
    Film1=Film(filename,pure)
    Film1.File=True
    #CreateDummyExperiment(
    #Film1=ASDFilm(filename,pol,sol,api)
    Film1.Diffusion1D()
